Fixtures
============

---

Common Bundle has [FixturesLoader](https://github.com/anzusystems/common-bundle/blob/main/src/DataFixtures/FixturesLoader.php) which you can use to load your application fixtures.

---

### Usage

Just extend [AbstractFixtures](https://github.com/anzusystems/common-bundle/blob/main/src/DataFixtures/Fixtures/AbstractFixtures.php). If your application is using autoconfiguration, it will autoconfigure your service with tag `anzu_systems_common.data_fixtures` and fixtures loader will use your own fixture generator. In case you are not using autoconfiguration, tag your service on your own.

Each fixture generator should extend [AbstractFixtures](https://github.com/anzusystems/common-bundle/blob/main/src/DataFixtures/Fixtures/AbstractFixtures.php):

```php
/**
 * @extends AbstractFixtures<User>
 */
final class UserFixtures extends AbstractFixtures
{
    public function __construct(
        private UserManager $userManager,
    ) {
    }

    public static function getIndexKey(): string
    {
        return User::class;
    }
    
    public function load(ProgressBar $progressBar): void
    {
        /** @var User $user */
        foreach ($progressBar->iterate($this->getData() as $user) {
            $user = $this->userManager->create($user);
            $this->addToRegistry($user);
        }
    }
    
    /**
     * @return iterable<User>
     */
    private function getData(): iterable
    {
        yield (new User())->setId(2);        
    }
}
```

`getIndexKey` can contain any identifier which you want to verbose during fixtures loading.

#### Dependencies

Fixtures generator can depend on other fixtures generators. Take this example of Blog fixtures generator: 

```php
/**
 * @extends AbstractFixtures<Blog>
 */
final class BlogFixtures extends AbstractFixtures
{
    public function __construct(
        private BlogManager $blogManager,
        private UserFixtures $userFixtures,
    ) {
    }

    public static function getIndexKey(): string
    {
        return User::class;
    }
    
    public static function getDependencies(): array
    {
        return [UserFixtures::class];
    }
    
    public function load(ProgressBar $progressBar): void
    {
        /** @var Blog $blog */
        foreach ($progressBar->iterate($this->getData() as $blog) {
            $blog = $this->blogManager->create($blog);
            $this->addToRegistry($blog);
        }
    }
    
    /**
     * @return iterable<Blog>
     */
    private function getData(): iterable
    {
        $user = $this->userFixtures->getRegistry()->get(2);
    
        yield (new Blog())
            ->setId(2)
            ->addOwner($user)
        ;        
    }
}
```

`FixturesLoader` will in this case first load UsersFixtures and then BlogFixtures, you can depend on multiple fixtures generators, priority will be resolved automatically.

#### Fixtures Registry

It's useful to register some generated fixtures into fixtures registry (keep on mind memory usage). `AbstractFixtures` provides for this some methods:
```php
public function getRegistry(): ArrayCollection;
public function addToRegistry(BaseIdentifiableInterface $entity): self;
public function findOneRegistryRecord(Closure $filter): ?BaseIdentifiableInterface;
```

The example of usage this helper methods is shown above in BlogFixtures generator.

#### Custom ID

Basically, entities often use autogenerated strategy for primary identifiers. You can change that by using helper methods in `AbstractFixtures`:
```php
public function useCustomId(): bool;
public function configureAssignedGenerator(): void;
```

If you need to assign your own ids, just override the `useCustomId` method and return true. Method `configureAssignedGenerator` already implements configuration of Doctrine's `AssignedGenerator`.
